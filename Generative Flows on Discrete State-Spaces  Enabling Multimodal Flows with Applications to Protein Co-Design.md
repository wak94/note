# Generative Flows on Discrete State-Spaces:  Enabling Multimodal Flows with Applications to Protein Co-Design

# 摘要

将离散数据与连续数据相结合是生成模型的一项重要能力。我们提出了离散流模型（Discrete Flow Models, DFMs），这是一种用于建模离散数据的新型基于流的模型，为在多模态连续与离散数据问题中应用基于流的生成模型提供了关键缺失环节。我们的核心洞见在于：通过连续时间马尔可夫链（Continuous Time Markov Chains），可以实现离散空间中与连续空间流匹配相对应的机制。DFMs 具有简洁的推导过程，不仅将离散扩散模型作为其特例自然包含在内，而且在性能上优于现有的基于扩散的方法。我们利用 DFM 方法构建了一个多模态的基于流的建模框架，并将其应用于蛋白质协同设计（protein co-design）任务，即学习同时生成蛋白质结构与序列的联合模型。我们的方法在协同设计任务上达到了当前最优的性能，并且同一个多模态模型还能灵活地用于单独生成序列或结构。

# 背景

将生成模型的能力扩展到处理离散与连续数据——我们称之为**多模态（multimodal）**——是推动其在科学领域广泛应用的一个基础性问题（Wang 等，2023）。一个需要多模态生成模型的应用实例是**蛋白质协同设计（protein co-design）**，其目标是联合生成连续的蛋白质结构以及对应的离散氨基酸序列（Shi 等，2022）。蛋白质的功能由其结构赋予，而序列则是构建该结构的“蓝图”。这种相互作用促使我们应同时生成结构与序列，而非孤立进行。为此，本工作的重点在于开发一个能够实现协同设计的多模态生成框架。

扩散模型（Sohl-Dickstein 等，2015；Ho 等，2020；Song 等，2020）已在多个应用中实现了最先进的性能。它们具备作为多模态框架的潜力，因为可以在连续和离散空间上同时定义。然而，其采样时间的不灵活性使其难以适用于多模态问题。即使在单一模态下，寻找最优采样参数也需要大量重新训练和评估（Karras 等，2022），这一问题在多模态情况下会进一步加剧。另一方面，基于流的模型（Liu 等，2023；Albergo & Vanden-Eijnden, 2023；Lipman 等，2023）通过更简单的框架改进了扩散模型，在采样灵活性方面表现更优（Ma 等，2024）。不幸的是，目前尚无法在离散空间上定义基于流的模型，这阻碍了我们构建多模态流模型。

为解决这一问题，我们引入了一种名为**离散流模型（Discrete Flow Models, DFMs）**的新型基于流的离散数据模型，从而解锁了完整的基于流的多模态生成建模框架。我们的核心洞见来自于认识到：可以利用**连续时间马尔可夫链（CTMCs）**来实现离散空间中的流模型。DFMs 是一种新的离散生成建模范式，相较于扩散模型更为灵活，允许在无需重新训练的情况下调整采样，并能与连续状态空间流简单结合，形成多模态流模型。

![image-20251106155020285](C:/Users/wak/AppData/Roaming/Typora/typora-user-images/image-20251106155020285.png)

图1A 提供了 DFMs 的概览。我们首先定义一个概率流 $p_t$，它从噪声线性插值到数据。然后，我们通过模拟一条随时间演化的序列轨迹 $x_t$ 来生成新数据，该轨迹遵循 $p_t$，这需要训练一个去噪神经网络以最小化交叉熵。序列轨迹可能包含许多或很少的转换，我们将这一特性称为 **CTMC 随机性（CTMC Stochasticity）**（图1B）。之前的离散扩散模型等价于在训练时选择特定的随机性，而我们则可以在推理阶段动态调整它，从而增强样本质量并控制样本分布属性。

利用 DFMs，我们能够通过为每个数据模态定义因子化流（factorized flows）来创建一个多模态流模型。我们将此能力应用于蛋白质协同设计任务，通过开发一种名为 **Multiflow** 的新型连续结构与离散序列联合生成模型。我们将用于序列生成的 DFM 与 Yim 等人（2023a）开发的基于流的结构生成方法相结合。以往的多模态方法要么只生成序列，要么只生成结构，然后使用预测模型推断剩余模态（参见第5节）。我们的**单一模型**能够同时生成序列与结构，并且可以条件化于任一模态。

在我们的实验中（第6节），我们首先在小规模文本数据上验证了 DFMs 优于离散扩散替代方案 D3PM（Austin 等，2021），这得益于其扩展的采样时间灵活性。随后，我们将重点转向主要任务，即评估 Multiflow 在联合生成蛋白质结构与序列的协同设计任务上的表现。Multiflow 实现了最先进的协同设计性能，同时数据蒸馏（data distillation）使其能够获得最先进的结构生成效果。我们发现 CTMC 随机性能够控制样本属性，如二级结构组成和多样性。逆折叠与正向折叠的初步结果表明，Multiflow 是通向通用蛋白质生成模型的一条有前景的路径。

我们的贡献总结如下：

- 我们提出了**离散流模型（DFMs）**，这是一种通过 CTMC 模拟概率流构建的新型离散生成建模方法。
- 我们将 DFMs 与连续流方法相结合，创建了一个多模态生成建模框架。
- 我们利用该多模态框架开发了 **Multiflow**，这是一种最先进的蛋白质协同设计生成模型，具备灵活的多模态蛋白质生成能力。

# 2. 预备知识

我们的目标是对离散数据进行建模，其中序列 $x \in \{1, \dots, S\}^D$ 具有 $D$ 个维度，每个维度取 $S$ 个状态之一。为便于阐述，我们假设 $D=1$；所有结果在附录 E 中讨论的 $D>1$ 的情况下同样成立。我们首先介绍一类称为**连续时间马尔可夫链（CTMCs）**（Norris, 1998）的连续时间离散随机过程，然后描述其与概率流的联系。

### 2.1 连续时间马尔可夫链

一个随时间 $t \in [0,1]$ 演化的序列轨迹 $x_t$，若遵循 CTMC，则会在当前状态停留一段时间，并周期性地跳跃到另一个随机选择的状态。我们在图1B中展示了示例轨迹。跳跃的频率和目的地由速率矩阵 $R_t \in \mathbb{R}^{S \times S}$ 决定，该矩阵的非对角线元素需满足非负约束。在下一个无穷小时间步 $dt$ 内，$x_t$ 跳跃到不同状态 $j$ 的概率为 $R_t(x_t, j) dt$。我们可以将转移概率写作：

$$
p_{t+dt|t}(j|x_t) =
\begin{cases}
R_t(x_t, j) dt & \text{当 } j \neq x_t \\
1 + R_t(x_t, x_t) dt & \text{当 } j = x_t
\end{cases}
\quad (1)
$$

$$
= \delta\{x_t, j\} + R_t(x_t, j) dt \quad (2)
$$

其中，$\delta\{i, j\}$ 是克罗内克函数（Kronecker delta），当 $i=j$ 时值为 1，否则为 0；而 $R_t(x_t, x_t) := -\sum_{k \neq x_t} R_t(x_t, k)$，以确保 $p_{t+dt|t}(\cdot | i)$ 的总和为 1。我们采用紧凑记法，用公式 (2) 代替公式 (1)。因此，$p_{t+dt|t}$ 是一个类别分布（Categorical distribution），其概率为 $\delta\{x_t, j\} + R_t(x_t, j) dt$，我们将其记作 $\text{Cat}(\delta\{x_t, j\} + R_t(x_t, j) dt)$：$j \sim p_{t+dt|t}(j|x_t) \iff j \sim \text{Cat}(\delta\{x_t, j\} + R_t(x_t, j) dt).$

在实践中，我们需要使用有限的时间间隔 $\Delta t$ 来模拟序列轨迹。可以通过欧拉步长（Euler steps）（Sun 等，2023b）来模拟序列轨迹：

$$
x_{t+\Delta t} \sim \text{Cat}(\delta\{x_t, x_{t+\Delta t}\} + R_t(x_t, x_{t+\Delta t}) \Delta t), \quad (3)
$$

其中序列从初始样本 $x_0 \sim p_0$ 在时间 $t=0$ 开始。速率矩阵 $R_t$ 与初始分布 $p_0$ 共同定义了 CTMC。

### 2.2 科尔莫戈罗夫方程

对于遵循 CTMC 动力学的序列轨迹，我们将其在时间 $t$ 的边缘分布记为 $p_t(x_t)$。科尔莫戈罗夫方程允许我们将速率矩阵 $R_t$ 与 $p_t(x_t)$ 的变化关联起来。其形式为：

$$
\partial_t p_t(x_t) = \underbrace{\sum_{j \neq x_t} R_t(j, x_t) p_t(j)}_{\text{流入}} - \underbrace{\sum_{j \neq x_t} R_t(x_t, j) p_t(x_t)}_{\text{流出}}
$$

流入与流出概率质量之间的差值即为边缘分布的时间导数 $\partial_t p_t(x_t)$。根据我们对 $R_t(x_t, x_t)$ 的定义，公式 (4) 可简洁地写为 $\partial_t p_t = R_t^\top p_t$，其中边缘分布被视为概率质量向量：$p_t \in [0,1]^S$。这定义了一个向量空间中的常微分方程（ODE）。我们将满足该 ODE 的一系列分布 $p_t$（$\forall t \in [0,1]$）称为**概率流**。

**关键词术语**：CTMC 由初始分布 $p_0$ 和速率矩阵 $R_t$ 定义。沿 CTMC 动力学采样的样本被称为**序列轨迹** $x_t$。**概率流** $p_t$ 是 $x_t$ 在每一时刻 $t$ 的边缘分布。如果 $\partial_t p_t = R_t^\top p_t$ 对所有 $t \in [0,1]$ 成立，我们称 $R_t$ **生成** $p_t$。

# 3. 离散流模型

离散流模型（DFM）是一种围绕概率流构建的离散数据生成模型，该概率流从噪声插值到数据。为了采样新的数据点，我们模拟一条与噪声到数据的概率流相匹配的序列轨迹。这种流的构造使我们能够将 DFM 与连续数据流模型相结合，以定义一个多模态生成模型。所有命题的证明见附录 B。

## 3.1 用于采样离散数据的流模型

我们首先构建一个数据生成概率流，称为**生成流** $p_t$，我们稍后将使用 CTMC 从中采样。该生成流从噪声插值到数据，其中 $p_0(x_0) = p_{\text{noise}}(x_0)$ 且 $p_1(x_1) = p_{\text{data}}(x_1)$。由于直接考虑 $p_t$ 较为复杂，流匹配的核心洞见是：使用一个更简单的数据点条件流 $p_{t|1}(\cdot | x_1)$ 来定义 $p_t$，我们可以将其显式写出。因此，我们可以将 $p_t$ 定义为：

$$
p_t(x_t) := \mathbb{E}_{p_{\text{data}}(x_1)} \left[ p_{t|1}(x_t | x_1) \right].
$$

条件流 $p_{t|1}(\cdot | x_1)$ 从噪声插值到数据点 $x_1$。这种条件化允许我们将流以闭式形式写出。我们可以根据具体应用的需要自由地定义 $p_{t|1}(\cdot | x_1)$。

在本文中，我们使用的条件流从均匀先验或人工引入的掩码状态 $M$ 线性插值到 $x_1$：

$$
p^{\text{unif}}_{t|1}(x_t | x_1) = \text{Cat}\left( t \delta\{x_1, x_t\} + (1-t) \frac{1}{S} \right)\\
p^{\text{mask}}_{t|1}(x_t | x_1) = \text{Cat}\left( t \delta\{x_1, x_t\} + (1-t) \delta\{M, x_t\} \right).
$$

> 在时间 $t$，以概率 $t$ 取数据点 $x_1$ ，以概率 $1−t$ 随机从所有类别中均匀采样;
>
> 在时间 $t$，以概率 $t$ 取数据点 $x_1$ ，以概率 $1−t$ 取掩码标记;

我们要求我们的条件流在 $t=1$ 时收敛于数据点 $x_1$，即 $p_{t|1}(x_t | x_1) = \delta\{x_1, x_t\}$。我们还要求条件流在 $t=0$ 时从噪声开始，即 $p_{t|1}(x_t | x_1) = p_{\text{noise}}(x_t)$。在我们的示例中，$p^{\text{unif}}_{\text{noise}}(x_t) = \frac{1}{S}$ 且 $p^{\text{mask}}_{\text{noise}}(x_t) = \delta\{M, x_t\}$。这两个要求确保了我们在公式 (5) 中定义的生成流 $p_t$ 按预期从 $t=0$ 时的 $p_{\text{noise}}$ 插值到 $t=1$ 时的 $p_{\text{data}}$。接下来，我们将展示如何通过利用 $p_t$ 对条件流的分解来从生成流中采样。

### 3.1.1 采样

为了使用生成流 $p_t$ 从 $p_{\text{data}}$ 中采样，我们需要访问一个能生成 $p_t$ 的速率矩阵 $R_t(x_t, j)$。给定一个 $R_t(x_t, j)$，我们可以使用公式 (3) 来模拟一条序列轨迹，该轨迹在 $t=0$ 时以边缘分布 $p_{\text{noise}}$ 开始，并在 $t=1$ 时以边缘分布 $p_{\text{data}}$ 结束。

公式 (5) 中对 $p_t$ 的定义表明，$R_t(x_t, j)$ 也可以被推导为一个更简单的条件速率矩阵的期望值。我们将 $R_t(x_t, j | x_1)$ 定义为一个能生成条件流 $p_{t|1}(x_t | x_1)$ 的数据点条件速率矩阵。我们现在将证明，$R_t(x_t, j)$ 确实可以被定义为对 $R_t(x_t, j | x_1)$ 的期望。

**命题 3.1**：如果 $R_t(x_t, j | x_1)$ 是一个能生成条件流 $p_{t|1}(x_t | x_1)$ 的速率矩阵，那么
$$
R_t(x_t, j) := \mathbb{E}_{p_{1|t}(x_1 | x_t)} \left[ R_t(x_t, j | x_1) \right]
$$

是一个能生成公式 (5) 中所定义的 $p_t$ 的速率矩阵。该期望是在 $p_{1|t}(x_1 | x_t) = \frac{p_{t|1}(x_t | x_1) p_{\text{data}}(x_1)}{p_t(x_t)}$ 上取的。

我们当前的目标是计算 $R_t(x_t, j | x_1)$ 和 $p_{t|1}(x_1 | x_t)$，以便将其代入公式 (7)。$p_{t|1}(x_1 | x_t)$ 是一个从噪声数据 $x_t$ 预测干净数据 $x_1$ 的分布，在第 3.1.2 节中，我们将训练一个神经网络 $p^{\theta}_{1|t}(x_1 | x_t)$ 来近似它。在第 3.2 节中，我们将展示如何推导出 $R_t(x_t, j | x_1)$ 的闭式表达。采样的伪代码见算法 1。

![image-20251106163436193](C:/Users/wak/AppData/Roaming/Typora/typora-user-images/image-20251106163436193.png)

我们在附录 G 中讨论了其他 CTMC 采样方法。我们的生成流构造方式源于条件流。

![image-20251106163501923](C:/Users/wak/AppData/Roaming/Typora/typora-user-images/image-20251106163501923.png)

这与 Lipman 等人（2023）提出的从条件概率路径构建生成概率路径的方法类似，不同之处在于，他们使用的是连续向量场来生成概率流，而我们使用的是一个生成概率流的速率矩阵。我们在表 1 中进一步展开这些联系。

### 3.1.2 训练

我们训练一个具有参数 $\theta$ 的神经网络 $p^{\theta}_{1|t}(x_1 | x_t)$，以标准交叉熵损失函数来近似真实的去噪分布，即学习在给定噪声数据 $x_t \sim p_{t|1}(x_t | x_1)$ 时预测干净数据点 $x_1$。

$$
\mathcal{L}_{\text{ce}} = \mathbb{E}_{p_{\text{data}}(x_1)} \mathbb{E}_{\mathcal{U}(t; 0,1)} \left[ \log p^{\theta}_{1|t}(x_1 | x_t) \right]
$$

其中 $\mathcal{U}(t; 0,1)$ 是区间 $[0,1]$ 上的均匀分布。$x_t$ 可以通过我们为 $p_{t|1}$ 写下的显式形式（例如公式 (6)）以无需模拟的方式从 $p_{t|1}(x_t | x_1)$ 中采样。

在附录 C 中，我们分析了 $\mathcal{L}_{\text{ce}}$ 与模型对数似然的关系，以及它与用于训练扩散模型的证据下界（ELBO）的关系。我们强调，$\mathcal{L}_{\text{ce}}$ 不依赖于 $R_t(x_t, j | x_1)$，因此我们可以将 $R_t(x_t, j | x_1)$ 的选择推迟到训练之后。这使得我们在离散数据采样时能够拥有推理时间的灵活性。

## 3.2 速率矩阵的选择

公式 (7) 中缺失的部分是一个能生成条件流 $p_{t|1}(x_t | x_1)$ 的条件速率矩阵 $R_t(x_t, j | x_1)$。存在许多可以生成相同 $p_{t|1}(x_t | x_1)$ 的 $R_t(x_t, j | x_1)$ 选择，我们将在命题 3.3 中稍后展示。

为了继续推进，我们首先给出一个有效的速率矩阵选择，并以此为基础构建一组能够生成 $p_{t|1}$ 的速率矩阵。在推理时，我们可以从该集合中挑选表现最佳的速率矩阵。我们为生成 $p_{t|1}$ 的速率矩阵定义的初始选择，当 $x_t \neq j$ 时为：$R^*_t(x_t, j | x_1) := \frac{\text{ReLU} \left( \partial_t p_{t|1}(j | x_1) - \partial_t p_{t|1}(x_t | x_1) \right)}{S \cdot p_{t|1}(x_t | x_1)}$

其中 $\text{ReLU}(a) = \max(a, 0)$，而 $\partial_t p_{t|1}$ 可以通过对 $p_{t|1}$ 的显式形式求导得到。这假设了 $p_{t|1}(x_t | x_1) > 0$，完整的表达式见附录 B.2。

我们首先启发式地证明 $R^*_t$ 的合理性，然后在命题 3.2 中证明它确实能生成 $p_{t|1}(x_t | x_1)$。$R^*_t$ 可以被理解为将概率质量分配给那些需要更多概率质量的状态。如果 $\partial_t p_{t|1}(j | x_1) > \partial_t p_{t|1}(x_t | x_1)$，那么状态 $j$ 需要获得比当前状态 $x_t$ 更多的概率质量，从而产生一个正速率。如果 $\partial_t p_{t|1}(j | x_1) \leq \partial_t p_{t|1}(i | x_1)$，那么状态 $x_t$ 不应向状态 $j$ 分配质量，因此使用 ReLU 函数。该速率随后应通过当前状态的概率质量进行归一化。ReLU 确保了 $R^*_t$ 的非对角线元素为正，并且其灵感来源于 Zhang 等人（2023）的工作。

**命题 3.2**：假设零质量状态，即 $p_{t|1}(j | x_1) = 0$，有 $\partial_t p_{t|1}(j | x_1) = 0$，则 $R^*_t$ 能生成 $p_{t|1}(x_t | x_1)$。

该证明很容易通过将 $R^*_t$ 和 $p_{t|1}(x_t | x_1)$ 代入科尔莫戈罗夫方程（公式 (4)）推导出来。

在 $p^{\text{unif}}_{t|1}$ 或 $p^{\text{mask}}_{t|1}$ 下，$R^*_t(x_t, j | x_1)$ 的形式很简单：$R^{*\text{unif}}_t = \frac{\delta\{x_t, j\} (1 - \delta\{x_t, x_1\})}{1-t}, \quad R^{*\text{mask}}_t = \frac{\delta\{x_t, j\} \delta\{x_t, M\}}{1-t}$

正如我们在附录 F 中所推导的那样。以 $R^*_t$ 为起点，我们现在可以构建一组所有能生成 $p_{t|1}$ 的速率矩阵。我们可以通过添加一个与 $p_{t|1}$ 满足细致平衡（detailed balance）条件的第二速率矩阵来实现这一点。

**命题 3.3**：设 $R^{\text{DB}}_t$ 为一个满足细致平衡条件的速率矩阵：

$$
p_{t|1}(i | x_1) R^{\text{DB}}_t(i, j | x_1) = p_{t|1}(j | x_1) R^{\text{DB}}_t(j, i | x_1)
$$

令 $R^{\eta}_t$ 由 $R^*_t$、$R^{\text{DB}}_t$ 和参数 $\eta \in \mathbb{R}^{\geq 0}$ 定义：$R^{\eta}_t := R^*_t + \eta R^{\text{DB}}_t.$

那么我们有 $R^{\eta}_t$ 能生成 $p_{t|1}(x_t | x_1)$，对于所有 $\eta \in \mathbb{R}^{\geq 0}$ 成立。

细致平衡条件直观上强制要求流入的概率质量 $p_{t|1}(j | x_1) R^{\text{DB}}_t(j, i | x_1)$ 等于流出的概率质量 $p_{t|1}(i | x_1) R^{\text{DB}}_t(i, j | x_1)$。因此，$R^{\text{DB}}_t$ 对概率流没有总体影响，可以添加到 $R^*_t$ 上，而组合后的速率矩阵仍能生成 $p_{t|1}$。在许多情况下，由于 $R^{\text{DB}}_t$ 元素之间的显式关系，公式 (9) 很容易求解，正如我们在附录 F 中所举例说明的。细致平衡此前已在 CTMC 生成模型（Campbell 等，2022）中用于进行事后推理调整。

### CTMC 随机性

现在我们有一组速率矩阵 $\{R^{\eta}_t : \eta \geq 0\}$，它们都能生成 $p_{t|1}$。我们可以将其中任何一个代入我们对 $R_t(x_t, j)$ 的定义（公式 (7)），并使用算法 1 来采样新的数据点。所选的 $\eta$ 值将影响我们正在模拟的 CTMC 的动力学。对于较大的 $\eta$ 值，$R^{\text{DB}}_t$ 影响的增加会导致状态间概率质量的大规模交换。这表现为序列轨迹中跳跃频率的增加。这导致 CTMC 的自相关时间变短，以及在给定当前状态下对未来状态的高度不可预测性。我们将这种由 $\eta$ 控制的行为称为 **CTMC 随机性**。图 1B 展示了高 $\eta$ 和低 $\eta$ 的示例。

在给定任务中，我们预期存在一个最优的随机性水平。额外的随机性可以提升连续扩散模型的性能（Cao 等，2023；Xu 等，2023），但过多的随机性可能导致性能不佳的退化 CTMC。在某些情况下，设置 $\eta=0$（即仅使用 $R^*_t$）会导致序列轨迹中跳跃次数最少，因为 $R^*_t$ 中的 ReLU 移除了那些本不需要交换质量的状态对（Zhang 等，2023）。

**命题 3.4**：对于 $p^{\text{unif}}_{t|1}$ 和 $p^{\text{mask}}_{t|1}$，$R^*_t$ 能生成 $p_{t|1}$，同时最小化序列轨迹中的期望跳跃次数。这假设了在附录 E 所列的因子化假设下的多维数据。

# 4. 多模态蛋白质生成模型

利用我们在离散状态空间上的流公式，我们现在可以将一个 DFM 与一个连续空间上的流相结合，以定义一个多模态生成流。我们利用此方法执行蛋白质结构-序列联合生成。一个蛋白质可以被建模为一个氨基酸残基的线性链，每个残基都分配有一个氨基酸和 3D 原子坐标。蛋白质协同设计的目标是联合生成氨基酸（序列）和坐标（结构）。以往的工作使用一个模态（序列或结构）上的生成模型，再用另一个独立模型来预测另一个模态（参见第 5 节）。相反，我们的方法使用一个单一的生成模型来同时采样两种模态：用于序列的 DFM 和用于结构的流模型 FrameFlow（Yim 等，2023a）。我们将我们的多模态流模型称为 **Multiflow**。

## 4.1 多模态流

遵循 FrameFlow，我们将蛋白质结构称为每个残基的**主链原子坐标**。我们将侧链原子的建模作为后续工作。结构被表示为 SE(3) 中的元素，以捕捉沿主链的局部坐标系的刚性（Yim 等，2023b）。一个长度为 $D$ 个残基的蛋白质可以表示为 $\{(x^d, r^d, a^d)\}_{d=1}^D$，其中 $x \in \mathbb{R}^3$ 是残基的碳-α 原子相对于全局参考系的平移，$r \in \text{SO}(3)$ 是残基局部坐标系相对于全局参考系的旋转，而 $a \in \{1, \dots, 20\} \cup \{M\}$ 是 20 种氨基酸之一或掩码状态 $M$。为简洁起见，我们将残基状态记为 $T^d = (x^d, r^d, a^d)$，并将整个蛋白质的结构和序列记为 $\mathbf{T} = \{T^d\}_{d=1}^D$。我们将多模态条件流 $p_{t|1}(\mathbf{T}_t | \mathbf{T}_1)$ 定义为一个概率密度函数（针对连续变量）和一个概率质量函数（针对离散变量）的简写形式。我们定义 $p_{t|1}(\mathbf{T}_t | \mathbf{T}_1)$ 以在维度和模态上进行因子化：

$$
p_{t|1}(\mathbf{T}_t | \mathbf{T}_1) := \prod_{d=1}^{D} p_{t|1}(x^d_t | x^d_1) p_{t|1}(r^d_t | r^d_1) p_{t|1}(a^d_t | a^d_1)
$$

遵循 Yim 等人（2023a），$p_{t|1}(x^d_t | x^d_1)$ 和 $p_{t|1}(r^d_t | r^d_1)$ 通过指定如何从 $p_{t|1}(x^d_t | x^d_1)$、$p_{t|1}(r^d_t | r^d_1)$ 生成样本 $x^d_t$、$r^d_t$ 来隐式定义：

$$
x^d_t = t x^d_1 + (1-t) x^d_0, \quad x^d_0 \sim \mathcal{N}(0, I)
$$

$$
r^d_t = \exp_{r^d_0} \left( t \log_{r^d_0}(r^d_1) \right), \quad r^d_0 \sim \mathcal{U}_{\text{SO}(3)}
$$

其中 $\exp$ 和 $\log$ 分别是指数映射和对数映射。$\mathcal{U}_{\text{SO}(3)}$ 是 SO(3) 上的均匀分布。遵循第 3 节，$p_{t|1}(a^d_t | a^d_1)$ 被显式定义：

$$
p_{t|1}(a^d_t | a^d_1) = \text{Cat}\left( t \delta\{a^d_1, a^d_t\} + (1-t) \delta\{M, a^d_t\} \right)
$$

遵循此条件流的条件轨迹将在连续模态上表现为一个常微分方程（ODE），而在氨基酸上表现为一个 CTMC。该条件 ODE 在平移和旋转上的参数化是通过条件速度 $v^d_x(x^d_t | x^d_1) \in \mathbb{R}^3$ 和 $v^d_r(r^d_t | r^d_1) \in \text{Tan}_{r^d_t}\text{SO}(3)$ 实现的（Yim 等，2023a）。$v^d_x$ 是一个标准的欧几里得向量场，而 $v^d_r$ 是黎曼流形 SO(3) 上的一个向量场（Chen & Lipman, 2023）。该轨迹可以使用步长为 $\Delta t$ 的欧拉步长模拟：

$$
x^d_{t+\Delta t} = x^d_t + v^d_x(x^d_t | x^d_1) \Delta t\\
r^d_{t+\Delta t} = \exp_{r^d_t} \left( \Delta t \cdot v^d_r(r^d_t | r^d_1) \right)\\
a^d_{t+\Delta t} \sim \text{Cat}\left( \delta\{a^d_t, a^d_{t+\Delta t}\} + R^d_t(a^d_t, a^d_{t+\Delta t} | a^d_1) \Delta t \right).
$$

我们选择 $v^d_x$，使其在 $\mathbb{R}^3$ 中单独生成由公式 (11) 给出的 $p_{t|1}(x^d_t | x^d_1)$。类似地，对于 $v^d_r$ 和 $R^d_t$，它们被选择为分别单独生成由公式 (12) 给出的 $p_{t|1}(r^d_t | r^d_1)$ 和由公式 (13) 给出的 $p_{t|1}(a^d_t | a^d_1)$。$v^d_x$、$v^d_r$ 和 $R^d_t$ 的显式形式如下：

$$
v^d_x(x^d_t | x^d_1) = (x^d_1 - x^d_t) / (1-t)\\
v^d_r(r^d_t | r^d_1) = \log_{r^d_t}(r^d_1) / (1-t)\\
R^d_t(a^d_t, j^d | a^d_1) = \delta\{j^d, a^d_t\} \delta\{a^d_t, M\} / (1-t).
$$

这些速度遵循 Yim 等人（2023a）的工作，速率矩阵则在附录 F.1 中推导得出，假设 $\eta=0$。以下命题验证了这些选择与我们对 $p_{t|1}(\mathbf{T}_t | \mathbf{T}_1)$ 的初始定义是一致的。

**命题 4.1**：由公式 (15) 定义的多模态过程具有由公式 (10) 给出的流 $p_{t|1}(\mathbf{T}_t | \mathbf{T}_1)$。

我们希望现在能够采样一条遵循无条件流的轨迹。仿照命题 3.1，我们再次发现，所需的无条件速度和速率矩阵分别是其各自条件量的期望值。

**命题 4.2**：以下速度和速率矩阵共同生成 $p_t(\mathbf{T}_t) = \mathbb{E}_{p_{\text{data}}(\mathbf{T}_1)} \left[ p_{t|1}(\mathbf{T}_t | \mathbf{T}_1) \right]$：

$v^d_x(\mathbf{T}_t) = \mathbb{E}_{p_{1|t}(x^d_1 | \mathbf{T}_t)} \left[ v^d_x(x^d_t | x^d_1) \right]$

$v^d_r(\mathbf{T}_t) = \mathbb{E}_{p_{1|t}(r^d_1 | \mathbf{T}_t)} \left[ v^d_r(r^d_t | r^d_1) \right]$

$R^d_t(\mathbf{T}_t, j^d) = \mathbb{E}_{p_{1|t}(a^d_1 | \mathbf{T}_t)} \left[ R^d_t(a^d_t, j^d | a^d_1) \right].$

我们注意到，尽管条件流被定义为在模态和维度上进行因子化，但无条件生成流具有耦合的模态和维度，因为每个速度和速率矩阵都依赖于整个被破坏的蛋白质状态 $\mathbf{T}_t$。

到目前为止，我们假设所有模态中的噪声水平相同。为了实现灵活的采样选项，我们可以为结构使用一个独立于序列噪声水平 $t$ 的噪声水平 $\tilde{t}$（Albergo 等，2023）。我们令 $\mathbf{T}_{t,\tilde{t}} = (x^{1:D}_t, r^{1:D}_{\tilde{t}}, a^{1:D}_{\tilde{t}})$，并使用一个条件流：$p_{t,\tilde{t}|1}(\mathbf{T}_{t,\tilde{t}} | \mathbf{T}_1) = \prod_{d=1}^{D} p_{t|1}(x^d_t | x^d_1) p_{\tilde{t}|1}(r^d_{\tilde{t}} | r^d_1) p_{\tilde{t}|1}(a^d_{\tilde{t}} | a^d_1).$

无条件流随后变为 $p_{t,\tilde{t}}(\mathbf{T}_{t,\tilde{t}}) = \mathbb{E}_{p_{\text{data}}(\mathbf{T}_1)} \left[ p_{t,\tilde{t}|1}(\mathbf{T}_{t,\tilde{t}} | \mathbf{T}_1) \right]$，其中命题 4.2 中无条件速度和速率矩阵的期望值现在使用 $p_{1|t,\tilde{t}}(\cdot | \mathbf{T}_{t,\tilde{t}})$ 而不是 $p_{1|t}(\cdot | \mathbf{T}_t)$ 来计算。

## 4.2 训练

在训练过程中，我们的网络将以噪声蛋白质 $\mathbf{T}_{t,\tilde{t}}$ 作为输入，并预测去噪后的平移 $\hat{x}_1(\mathbf{T}_{t,\tilde{t}})$、旋转 $\hat{r}_1(\mathbf{T}_{t,\tilde{t}})$ 和氨基酸分布 $p_\theta(a_1 | \mathbf{T}_{t,\tilde{t}})$。然后，我们用这些预测量来参数化无条件速度和速率矩阵：

$v^d_x(\mathbf{T}_{t,\tilde{t}}) = \frac{\hat{x}^d_1(\mathbf{T}_{t,\tilde{t}}) - x^d_t}{1-t}, \quad v^d_r(\mathbf{T}_{t,\tilde{t}}) = \frac{\log_{r^d_t}(\hat{r}^d_1(\mathbf{T}_{t,\tilde{t}}))}{1-t},$

$R^d_t(\mathbf{T}_{t,\tilde{t}}, j^d) = \frac{p_\theta(a^d_1=j^d | \mathbf{T}_{t,\tilde{t}})}{1-t} \delta\{a^d_t, M\}.$

为了使这些参数与命题 4.2 中给出的最优值相匹配，我们最小化以下损失函数：

$$
\mathbb{E}\left[ \sum_{d=1}^{D} \frac{\| \hat{x}^d_1(\mathbf{T}_{t,\tilde{t}}) - x^d_t \|^2}{1-t} - \log p_\theta(a^d_1 | \mathbf{T}_{t,\tilde{t}}) \right.\left. + \frac{\| \log_{r^d_t}(\hat{r}^d_1(\mathbf{T}_{t,\tilde{t}})) - \log_{r^d_t}(r^d_t) \|^2}{1-t} \right].
$$

其中期望是针对 $t, \tilde{t} \sim \mathcal{U}(0,1)$，$\mathbf{T}_{1,1} \sim p_{\text{data}}$ 和 $\mathbf{T}_{t,\tilde{t}} \sim p_{t,\tilde{t}|1}(\mathbf{T}_{t,\tilde{t}} | \mathbf{T}_{1,1})$ 计算的。

我们独立的 $t, \tilde{t}$ 目标使得模型能够学习序列和结构之间不同相对水平的破坏。公式 (16) 对应于连续数据的流匹配损失和离散氨基酸的 DFM 损失（公式 (8)）。神经网络架构在 FrameFlow 的基础上进行了修改，采用了更大的 Transformer、更小的 Invariant Point Attention 以及额外的多层感知机头来预测氨基酸的对数几率（logits）。
## 4.3 采样

为了对生成模型进行采样，我们使用公式 (14) 中的更新方程，但采用学习到的无条件速度和速率矩阵。此外，我们发现，通过使用 Bose 等人（2023）提出的指数速率调度器来处理旋转，可以提升样本质量。在实践中，这意味着 $v^d_r$ 具有以下形式：

$$v^d_r(\mathbf{T}_{t,\tilde{t}}) = c \cdot \log_{r^d_t}(\hat{r}^d_1(\mathbf{T}_{t,\tilde{t}})).$$

我们遵循 Yim 等人（2023a）的做法，取 $c=10$。在采样氨基酸时，我们还发现利用 Tang 等人（2022）提出的“纯度”（purity）来选择每一步中需要解掩码的索引是有益的。

训练时采用解耦的时间表的优势在于，我们可以自由地以任意组合的 $(t, \tilde{t})$ 进行任意采样。我们利用这一点来执行**条件性图像修复（conditional inpainting）**，即固定其中一个模态，通过将 $t$ 或 $\tilde{t}$ 设为 1 来实现。例如，将 $t=1$，然后使用欧拉步长从 $0$ 到 $1$ 更新 $\tilde{t}$，即可执行以结构为条件的序列生成。

我们在图 1C 和表 2 中总结了这些能力。

![image-20251106210824600](C:/Users/wak/AppData/Roaming/Typora/typora-user-images/image-20251106210824600.png)

